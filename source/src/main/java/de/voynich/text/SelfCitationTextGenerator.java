package de.voynich.text;

import de.voynich.text.util.*;

import java.util.*;

/**
 * Class <code>SelfCitationTextGenerator</code> with main()-method to start the text generation
 */
public class SelfCitationTextGenerator {

    public enum CURRIER {
        A, B
    }

    /** the text lines generated by generateText() */
    private List<String> generatedText = new ArrayList<>();

    /** list of already generated lines for choosing source glyphGroups from context */
    private List<List<GlyphGroup>> lineArrays = new ArrayList<>();

    /** list of already generated paragraph initial lines for choosing source glyphGroups */
    private List<List<GlyphGroup>> paragraphInitialLineArrays = new ArrayList<>();

    /** configuration */
    private Config config;

    public static void main(String[] args) {
        new SelfCitationTextGenerator();
    }

    /**
     * Constructor
     */
    public SelfCitationTextGenerator() {
        readConfig();

        config.setRandomSeed(config.randomSeed);
        initStatistics();
        generateText(config.linesToCreate, config.initialLines.length);

        config.saveGeneratedText(generatedText);
    }

    /**
     * read the config file
     */
    private void readConfig() {
        config = new Config();
    }

    /**
     * initialize statistics
     */
    private void initStatistics() {
        generatedText.clear();
        lineArrays.clear();
        paragraphInitialLineArrays.clear();

        config.init();

        int wordCount = 0;
        for (String line : config.initialLines) {
            String[] textArray = StringUtil.splitAsArray(line, " ");
            wordCount += textArray.length;
            for (String group : textArray) {
                GlyphGroup glyphGroup = new GlyphGroup(group, GlyphGroup.GENERATE_TYPE.INITIAL);
                if (Constants.DEBUG && !config.canFollow.isValid(glyphGroup)) {
                    throw new IllegalStateException();
                }
                config.statistics.remember(glyphGroup);
            }
            int lineLength = line.length();
            if (lineLength > Config.maxLineLength) {
                String newInitialLine = trimInitialLine(textArray);
                generatedText.add(newInitialLine);
            } else {
                generatedText.add(line);
            }
        }

        if (wordCount < 6) {
            config.statistics.remember(Constants.DAIIN_GLYPH_GROUP);
            config.statistics.remember(Constants.OL_GLYPH_GROUP);
            if (config.currierType == CURRIER.A) {
                config.statistics.remember(Constants.CHEODY_GLYPH_GROUP);
            } else {
                config.statistics.remember(Constants.CHEDY_GLYPH_GROUP);
            }
        }
    }

    /**
     * returns a array of strings that it fits into the available space
     * @param textArray
     * @return
     */
    private String trimInitialLine(String[] textArray) {
        String newInitialLine = "";
        for (String group : textArray) {
            int initialLineLength = newInitialLine.length();
            if (initialLineLength < config.maxLineLength) {
                if (initialLineLength == 0) {
                    newInitialLine = group;
                } else {
                    newInitialLine = newInitialLine + " " + group;
                }
            }
        }

        return newInitialLine;
    }

    /**
     * generate the text
     * @param linesToCreate
     * @param initialLineCount
     */
    private void generateText(int linesToCreate, int initialLineCount) {
        config.statistics.linesInParagraph = generatedText.size();
        config.statistics.linesInPage = generatedText.size();

        // generate <code>linesToCreate</code> numbers of text
        for (int i = config.statistics.linesInParagraph; i < linesToCreate; i++) {
            boolean isParagraphInitial = config.statistics.linesInParagraph == 0;
            boolean isParagraphFinal = false;

            // structure the text into pages and paragraphs
            config.statistics.newLine();
            if (config.statistics.linesInPage == config.pageLength || i == linesToCreate-1) {
                isParagraphFinal = true;
                config.statistics.newPage();
            } else {
                if (config.statistics.linesInPage < config.pageLength-2 && config.statistics.linesInParagraph > 3 && i < linesToCreate - 2) {
                    int rand = config.randomNumberGenerator.rand(100);
                    if (rand < config.statistics.linesInParagraph * 10) {
                        isParagraphFinal = true;
                        config.statistics.newParagraph();
                    }
                }
            }

            // generate a new line
            generatedText.add(generateLine(isParagraphInitial, isParagraphFinal, initialLineCount));
        }
    }

    /**
     * generate a line of text
     * @param isParagraphInitial true for the initial line
     * @param isParagraphFinal true for the last line
     * @param initialLineCount
     * @return
     */
    private String generateLine(boolean isParagraphInitial, boolean isParagraphFinal, int initialLineCount) {
        boolean isLineInitial = true;
        StringBuilder line = new StringBuilder();

        int maxLineLength = Config.maxLineLength;
        // for the last line paragraph limit the line length
        if (isParagraphFinal) {
            maxLineLength = config.randomNumberGenerator.rand(maxLineLength);
            if (maxLineLength < Config.minLineLength) {
                maxLineLength = Config.minLineLength;
            }
        }

        int count = 0;
        int tries = 0;
        List<GlyphGroup> glyphGroupList = new ArrayList<>();
        List<GlyphGroup> lastSourceGroups = null;
        GlyphGroup lastGeneratedGroup = null;
        while (line.length() + Math.max(tries-3,0) < maxLineLength)  {
            count++;
            int availablePlaceInLine = maxLineLength - line.length();

            // choose source groups
            List<GlyphGroup> sourceGroups = config.sourceGroupChooser.chooseSourceGroup(lineArrays, paragraphInitialLineArrays, glyphGroupList, config.statistics, isParagraphInitial, isLineInitial, initialLineCount); //glyphGroupList, isParagraphInitial /* isParagraphInitial */, isLineInitial /* isLineInitial */, linesInPage /* linesInPage */, initialLineCount /* initialLineCount */);

            boolean useSourceGroups = false;
            if (sourceGroups.get(0).getTokenCount() > 5) {
                // limit the usage of source words with more then four tokens
                int rand = config.randomNumberGenerator.rand(4);
                if (sourceGroups.get(0).length() < 4+rand) {
                    useSourceGroups = true;
                }
            } else {
                useSourceGroups = true;
            }
            // prevent that the same sourceGroup is used twice
            if (useSourceGroups && lastSourceGroups != null && lastSourceGroups.get(0).equals(sourceGroups.get(0))) {
                useSourceGroups = false;
            }
            // limit the usage of combined glyphGroups as source
            if (Config.methodCombinedGroupsDismissAsSourceProbability > 0) {
                if (useSourceGroups && sourceGroups.get(0).generateType == GlyphGroup.GENERATE_TYPE.COMBINE) {
                    if (sourceGroups.get(1).generateType == GlyphGroup.GENERATE_TYPE.COMBINE) {
                        useSourceGroups = false;
                    } else {
                        int rand = config.randomNumberGenerator.rand(100);
                        if (rand < Config.methodCombinedGroupsDismissAsSourceProbability) {
                            useSourceGroups = false;
                        }
                    }
                }
            }

            boolean forceUsage = false;
            // workaround to prevent an endless loop
            if ((!useSourceGroups && count > 100) || count > 105) {
                if (Constants.DEBUG) {
                    System.out.println("WARN! source=" + sourceGroups.get(0) + " useSourceGroups=" + useSourceGroups + " isParagraphInitial=" + isParagraphInitial + " isLineInitial=" + isLineInitial + " size()=" + glyphGroupList.size() + " line=" + line);
                }
                sourceGroups = config.statistics.suggestGroupsForce(count-100);
                useSourceGroups = true;
                if (count > 110) {
                    forceUsage = true;
                }
            }
            if (count > 130) {
                throw new IllegalStateException("ERROR! source=" + sourceGroups.get(0) + " useSourceGroups=" + useSourceGroups + " isParagraphInitial=" + isParagraphInitial + " isLineInitial=" + isLineInitial + " size()=" + glyphGroupList.size()+ " line=" + line);
            }

            // modify source groups
            if (useSourceGroups) {
                // see SlimGroupMorher.morphGroup()
                List<GlyphGroup> morphedGroups = config.groupMorpher.morphGroup(sourceGroups, lastGeneratedGroup, isParagraphInitial, isLineInitial);

                if (morphedGroups.size() > 0) {
                    GlyphGroup firstGroup = morphedGroups.get(0);
                    boolean useMorphedGroups = config.canFollow.hasValidStartGlyph(firstGroup);
                    // limit repeated words
                    boolean equalLastGroup = glyphGroupList.size() > 0 && (firstGroup.equals(glyphGroupList.get(glyphGroupList.size() - 1)));
                    if (equalLastGroup) {
                        int rand = config.randomNumberGenerator.rand(100);
                        useMorphedGroups = rand < 50;
                    } else {
                        // prevent that to many words of the same type exists in a row
                        boolean isTypeI = firstGroup.isTypeI();
                        boolean isTypeDy = firstGroup.isTypeDy();
                        boolean isTypeOl = firstGroup.isTypeOl();
                        if (isTypeI && config.statistics.repeatedTokensI > config.maxRepeatCount) {
                            useMorphedGroups = false;
                        }
                        if (isTypeDy && config.statistics.repeatedTokensDy > config.maxRepeatCount) {
                            useMorphedGroups = false;
                        }
                        if (isTypeOl && config.statistics.repeatedTokensOl > config.maxRepeatCount) {
                            useMorphedGroups = false;
                        }
                        if (!isTypeI && !isTypeDy && !isTypeOl && config.statistics.repeatedTokensUnknown > config.maxRepeatCount) {
                            useMorphedGroups = false;
                        }
                    }

                    // add modified groups
                    if (useMorphedGroups || forceUsage) {
                        count = 0;
                        for (int i = 0; i < morphedGroups.size(); i++) {
                            GlyphGroup morphedGroup = morphedGroups.get(i);

                            // if not enough space trim the modified group
                            if (availablePlaceInLine - morphedGroup.length() <= 0) {
                                morphedGroup = tryToTrim(morphedGroup, availablePlaceInLine /* availableLength */);
                            }

                            // if there is enough space append the newly generated group
                            if (availablePlaceInLine - morphedGroup.length() >= 0) {
                                if (i == 0) {
                                    if (isLineInitial) {
                                        isLineInitial = false;
                                    } else {
                                        // add space
                                        line.append(" ");
                                        availablePlaceInLine -= 1;
                                    }
                                } else {
                                    // add space
                                    line.append(" ");
                                    availablePlaceInLine -= 1;
                                }
                                // add morphedGroup
                                glyphGroupList.add(morphedGroup);
                                config.statistics.remember(morphedGroup);
                                lastGeneratedGroup = morphedGroup;
                                line.append(morphedGroup.glyphGroup);
                                availablePlaceInLine -= morphedGroup.length();
                                tries = 0;
                            } else {
                                tries += 1;
                            }
                        }
                    }
                }
            }
        }

        // add line
        lineArrays.add(glyphGroupList);
        if (isParagraphInitial) {
            paragraphInitialLineArrays.add(glyphGroupList);
        }

        return line.toString();
    }

    /**
     * generate shorter groups if the remaining place is limited
     * @param glyphGroup
     * @param availableLength
     * @return
     */
    private GlyphGroup tryToTrim(GlyphGroup glyphGroup, int availableLength) {
        int length = glyphGroup.length();

        boolean changed = false;
        List<String> newTokens = glyphGroup.copyTokens();

        // change last token 'ol' --> 'om'
        String lastToken = newTokens.get(newTokens.size()-1);
        String newToken = Glyph.replaceLineFinalGlyph(lastToken);
        if (!lastToken.equals(newToken)) {
            length -= lastToken.length();
            length += newToken.length();
            newTokens.set(newTokens.size()-1, newToken);
            changed = true;
        }

        // try to substitute tokens
        for (int i = 0; i < newTokens.size(); i++) {
            if (availableLength < length) {
                String token = newTokens.get(i);
                Substitution substitution = Glyph.searchShorterGlyph(token);
                if (substitution != null) {
                    String subst = substitution.first();
                    newTokens.set(i, subst);
                    length -= token.length();
                    length += subst.length();
                    changed = true;
                }
            }
        }

        // remove tokens
        while (availableLength < length && newTokens.size() > 2) {
            String firstToken = newTokens.remove(0);
            length -= firstToken.length();
            changed = true;
        }

        // return new group
        if (changed) {
            return new GlyphGroup(newTokens, GlyphGroup.GENERATE_TYPE.SHORTEN);
        }

        return glyphGroup;
    }
}
